摘自侯跃伟《前端开发必知必会》

## 浏览器的运行机制

Chrome 是多进程的，丙个进程之间以 IPC(Inter Process Communication）消息的方式进行通信，顶层由一个 Browser Process(浏览器进程)来协调浏览器的其他进程，如图 4-1 所示。

### Chrome 的主要进程及职责

- Browser Process(浏览器进程)：负责包括地址栏、书签栏，以及前进或后退按钮等工作；负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问等。
- Renderer Process(渲染进程)：主要负责网页渲染。
- Plugin Process(插件进程)：管理一个网页用到的所有插件，比如逐渐被淘汰的 Flash 插件等。
- GPU Process(GPU 进程)：处理 GPU 相关的任务。
- Utility Process(工具进程)：负责任务初始化。

从上面各个进程的职责来看，浏览器进程主要协调 Tab 页签之外的工作，并且对这些工作进行了细粒度的划分，主要使用不同的线程进行处理：

- UI 线程：控制浏览器上的按钮及输入项等。
- network 线程：处理网络请求，从网上获取数据。
- storage 线程：控制文件等的访问。

现在，我们回到前面那个面试题——从地址栏输入 URL 到页面加载完成，中间都经历了什么？地址栏中输入输网址并单击“Enter”键后到看到整个页面，大概可分成如下几步：

### 第 1 步，处理用户输入。

先由 UI 线程判断用户输入的是一个网址还是一个要查询的关键字。因为 Chrome 中的地址栏也是一个输入框。UI 线程负责解析内容，并判断是把输入的内容交给查询引擎，还是导航到具体的网站。

### 第 2 步，开始导航。

单击“Enter”键，UI 线程通知 network 线程获取网页内容，并控制 Tab 页上的 Spinner 展现，表示正在努力加载。network 线程会执行 DNS 查询，随后为请求建立 TLS 连接。

DNS(运行在 UDP 上)是互联网上域名和 IP 地址相互映射的分布式数据库。有了 DNS，用户无须记住每个域名的 IP 地址就可以上网。比如，当在地址栏中输入某网址时，DNS 服务器就可以解析该主机名得到 IP 地址，这个过程就叫作域名解析。

主机到 IP 地址的映射一般有两种方式：静态映射和动态映射。区别在于：静态映射是在每台设备上分别配置映射关系，各自维护，只能独享；动态映射是建立一套 DNS 系统，并在该系统上配置映射关系，各域名解析都用这套系统，可以共享。

如果 network 线程接收了 301 状态码并重定向了请求头，那么 network 线程会通知 UI 线程“服务器要求重定向”，随后加载新的 URL。

### 第 3 步，读取响应体。

一旦服务器返回内容，network 线程就会读取响应主体中的 MIME 类型信息，“Content-Type”字段为返回内容的格式，“Content-Length”字段为响应主体的内容长度。(Multipurpose Internet Mail Extensions 多用途互联网邮件扩展类型)

网页的 MME 类型信息为“test/html”。接下来把这些数据传递给渲染进程。如果是压缩文件或者其他文件，就把相关数据传输给下载管理器。

Safe Browsing 检查也会在此时被触发，如果域名或者请求内容匹配到已知的恶意站点，则 network 线程会显示一个警告页。此外，CORB(Cross Origin Read Blocking)检测也会被触发，确保敏感数据不会被传递给渲染进程。

### 第 4 步，查找渲染进程。

当上述所有检查完成并且通过安全检查后，network 线程确信浏览器可以导航到请求的页面，就会通知 UI 线程数据已经就绪，这时 U 线程会查找一个渲染进程进行网页渲染。其实，为了能快速响应，UI 线程会预查找和启动一个渲染线程，如果可以访问，则该渲染进程继续。如果有重定向，则废弃准备好的线程并重启一个线程。

### 第 5 步，确认导航。

经过上面的步聚，数据已就绪，渲染线程也已经创建，可以说是“万事俱备，只欠东风” 了。这个“东风”是什么呢？就是前面提到的进程间的通信，即 IPC 消息。浏览器进程会给谊染进程发送 IPC 消息来确认导航。一旦浏览器进程收到渲染进程的渲染确认回复，导航过程就结束了，页面加载过程开始，如图 4-2 所示。

此时，地址栏已更新为新网址，呈现新网页内容。History Tab 页同样会更新，此时可以通过返回键返回到原来的页面。为了让 Tab 页签或者窗口在关闭后能够恢复，这些信息都会被保存到硬盘中。

### 第 6 步，额外的操作。

一旦导航被确认，渲染进程就会加载资源并渲染页面。渲染流程会在后面重点介绍。渲染进程在渲染所有的页面并且触发所有帧的 onload 事件后，会回到浏览器进程发送 IPC 信号，UI 线程停止展示 Tab 页签中的 Spinner。

当输入另一个 URL 加载新页面时，上面的加载流程会重新执行；当出现新的导航请求时，浏览器进程会通知渲染进程进行相关检查，并对相关事件进行处理，所有代码的执行都由渲染进程完成。

当通过 JavaScript 代码(window.location=＂htp:/xxx.com＂)导航到新站点时，渲染进程会首先检查 beforeunload 事件，导航请求由渲染进程传递给浏览器进程。

### 关于 Service Worker

如果页面注册了 Service Worker，则可以通过该方案实现网络代理。如果 Service Worker 被设置为从本地缓存中获取数据，就没有必要从网上重新请求了。

值得注意的是，Service Worker 也是运行在渲染进程中的代码，但是与前文所述流程略有不同.

当 Service Worker 被注册时，其作用域会被保存。当有导航时，network 线程会在注册过的 Service Worker 的作用城中查找相关城名。如果存在相关域名。则 UI 线程会查找一个渲染进程来处理相关代码。Service Worker 既可以只从缓存中加载数据，终止对网路的请求，也可以从网络上请求新的数据。

上述是浏览器渲染的基本过程。在上述流程中，与 Web 开发紧密相关的是渲染进程。

## 下面重点介绍渲染进程是如何工作的。

前面提到，渲染进程负责 Tab 页内的所有事情，其职责是把 HTML、CSS 和 JavaScript 代码转换为可与用户交互的 Web 页面。在渲染进程中主要包含以下线程：

- 主线程(Main Thread)：处理用户输入的大部分代码。
- 工作线程(Worker Thread):如果使用 Web Worker 或者 Service Worker，则该线程负责处理一部分 JavaScript 代码。
- 排版线程(Compositor Thread)：主要负责渲染页面。
- 光栅线程(Raster Thread)：负责组合不同的层形成帧。

后面会详细介绍这几个线程。下面重点介绍渲染进程。

### 1.构建 DOM 树

导航在确认信息收到后，渲染进程开始接收 HTML 文档数据，主线程也开始把字符串解析成 DOM 树。

### 2.加载子资源

在网页中常常包含 image、CSS 和 JavaScript 等资源，这些资源通常可从网上下载或者从缓存中获取。主进程可以在构建 DOM 树的过程中逐个加载资源。为了加速访问，preload scanner 也会同时运行。如果 HTML 中存在“ ` ”（反单引号 backquote)等标签，则 preload scanner 会把这些请求传递给 network 线程进行相关资源的下载。

### 3.对 JavaScript 代码的处理

当 HTML 在解析过程中发现标签时，它会暂停解析 HTML 文档，转而去加载、解析和执行 JavaScript 代码。这是因为 JavaScript 代码可能会改变 HTML 的结果，所以必须在执行 JavaScript 代码后再解析 HTML，如图 4-3 所示。

通常情况下，在 Tokenizer 阶段处理的 HTML 数据流既可能来自网络线程，也可能是客户端的代码。实际上，开发者可以用多种方式告知浏览器应如何应对某个资源，比如在标签上添加 async 或 defer 等属性，浏览器会异步加载和执行 JavaScript 代码，而不会阻塞渲染。

defer 和 async 的区别是：defer 是在整个页面正常渲染结束后(DOM 结构完全生成，其他脚本也执行完)才会执行；而 async 是只要脚本下载完，就中断渲染，先执行这个脚本，再回到渲染流程。需要注意的是，如果有多个 defer 脚本，则会按照它们在页面中定义的顺序进行加载，如果有多个 async 脚本，则不能保证加载顺序。

### 4.CSS 样式计算

仅仅渲染 DOM 树还不足以获得页面的样式信息，主进程还会基于 CSS 选择器解析 CSS，获取每个节点的最终计算样式值。

在 Web 开发过程中，即使不为元素提供任何 CSS，浏览器也会为每个元素都添加默认的样式值，比如最简单的 `<h1>`就比 `<h2>` 的样式值要大。

### 5.布局

在树的结构渲染完成后将执行布局处理(Layout Process)，即为每个节点都设置它在测览器上显示的坐标。

通过遍历 DOM 树及相关元素的计算样式，主线程会构建出包含每个元素的二维坐标 (x,y) 信息及盒子大小的布局树。布局树和 DOM 树类似，但是其中包含页面可见的元素。如果一个元素被设置为 display:none，那么这个元素就不会出现在布局树上。伪元素虽然在 DOM 树上不可见，但是在布局树上是可见的。

### 6.绘制

即使有了 DOM 元素、样式信息和布局树信息，也不能正确地绘制各元素。因为必须知道绘制各元素的先后顺序，才能准确地绘制整个页面。在绘制阶段，主线程会遍历布局树来创建绘制记录。绘制记录可以被看作记录各元素绘制先后顺序的笔记，比如先绘制背景，再绘制文本，接着绘制长方形，等等。

### 7.合成帧

复合是一种把页面分割为不同的层并单独栅格化，随后组合为帧的技术。不同层的组合由合成器线程(Compositor)完成。

主线程会遍历布局树来创建层(Layer Tree)。添加了 wil-change CSS 属性的元素会被看作单独的一层，注意，如果给每一个元素都加上 wil-change 属性的元素，那么组合过多的层可能会比在每一帧上都栅格化某些部分更慢。

创建层之后，即渲染顺序确定后，主线程会把这些信息通知给合成器线程，合成器线程会把各层栅格化。因为有的层的可以达到整个页面的大小，所以合成器线程会将它们分成多个磁贴，并将每个磁贴都发送给栅格线程，栅格线程会栅格化每一个磁贴并存储在 GPU 的显存中。

一旦磁贴被光栅化，合成器线程就会收集绘制四边形的磁贴信息来创建合成帧。合成帧可以过 IPC 消息传递给浏览器进程。浏览器的 UI 改变或者其他扩展的渲染进程（如扩展插件）也可以添加合成帧，而这些合成帧会被传递给 GPU，以便展示在屏幕上。如果发生滚动，则合成器线程会创建另一个合成帧并发送给 GPU。

合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JavaScript 代码的执行，这也是合成器相关的动画最流畅的原因之一。如果某个动画动涉及布局或者绘制的调整，就会涉及主线程的重新计算，自然会慢得多。

### 8.事件处理

浏览器通过对不同事件的处理进行交互。浏览器的输入性事件是平时开发经常接触的，一般分为三类：键盘事件、手势事件和鼠标事件。

当用户在屏幕上触发 touch 等手势时，首先收到手势信息的是浏览器进程。不过浏览器进程只会感知在哪里发生了手势，对 Tab 页内容的处理是由渲染进程处理的。当事件发生时，浏览器进程会给渲染进程发送事件类型(touch)及相应的坐标，随后渲染进程找到事件对象并执行所有绑定在目标对象上的处理函数，这时主线程就不得不出来“工作”了。如果在页面中没有绑定相关事件，则组合器？合成器 线程可以独立于主线程创建组合帧。

### 9.理解非快速滚动区域(non-fast scrollable region)

众所周知，JavaScript 是单线程的，当页面合成时，合成器线程会标记页面中绑定事件处理器的区域为非快速滚动区域(non-fast scrollable region)，合成器线程会把发生在此处的事件发送给主线程。如果事件没有发生在这些区域，则合成器线程会直接合成新的帧，而不用等主线程的响应。在 Web 开发中，常用的事件处理是事件委托，基于事件冒泡和捕捉机制。在实际开发中，我们常常在 body 上绑定事件：

```
document.body.addEventListener('touchstart',event =>｛
    if (event.target ==area){
    event.preventDefault();
    }});
```

DOM 二级事件规定的事件流包含三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

从整个浏览器的角度来看，整个页面都被标记成了非快速滚动区域。这意味着合成器线程需要和主线程通信并等待反馈，这时流畅的合成器独立处理合成帧的模式就失效了。

为了优化，我们可以为事件处理函数传递 passive:true 参数，这样浏览器就能既监听相关事件，又能让组合器线程在等主线程响应前构建新的组合帧了：

```
document.body.addEventListener(＇touchstart＇，event =＞ {
    if (event.target ===area){
    event.preventDefault()
    })
(passive:true));
```

不过上述写法可能会带来另一个问题，假设某个区域只想横向滚动，则使用 passive:true 可以实现平滑滚动，但是垂直方向的滚动可能会早于 eventpreventDefa 的执行，这时就需要通过 event.cancelable 来阻止这种情况的发生：

```
docuent.body.addEventListeer(‘pointermove’, event =>{
    if (event.cancelable){
    event.preventDefault();//阻止滚动
    },
{passive:true});
```

另外，可以通过 CSS 样式实现：

```
#area{
    touch-action: pan-x;
}
```

### 10.查找事件源

当组合器线程发送输入事件给主线程时，主线程首先会进行命中测试(hit test)来查找对应目标事件。命中测试会基于在渲染过程中生成的绘制记录(paint records)查找事件发生坐标下存在的元素，如图 4-4 所示。

### 11.事件优化

一般来说，屏幕的刷新速率为 60fps，但是某些事件的触发量不止这个值，出于优化的目的 Chrome 会合并连续的事件（如 wheel、mousewheel、mousemove，pointermove 和 thouchmove 等）， 并延迟到下一帧渲染时执行。

而如 keydown、keyup、mouseup、mousdown，touchstart 和 touchend 等非连续性事件则会被触发。合并事件虽然能提升性能，但如果是绘画等应用，则很难绘制一条平滑的曲线，此时可以使用 getCoalescedEvents API 来获取组合事件，示例代码如下：

```
window.addEventListener(＇pointermove＇，event =＞{
    const events =event.getCoalescedEvents();
    for (let event of events){
    const x = event.pageX;
    const y  = event.pageY;
    //draw a line using x and y coordinates.
    }});
```
